{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\"; // custom Hooks in React need to start with \"use\"\n\nconst useFetch = url => {\n  _s();\n\n  const [data, setData] = useState(null);\n  const [isPending, setIsPending] = useState(true);\n  const [error, setError] = useState(false); // useEffect runs a function after every render of the component\n  // If the state of the page is changed in useEffect, this triggers a rerender and then an infinite loop\n\n  useEffect(() => {\n    const abortConst = new AbortController(); // this { signal : abortConst.signal } prevents the fetch from running normally after abortConst.abort() is fired. Anyway this, throws an error so we still end up in the catch block and the code there is executed\n\n    fetch(url, {\n      signal: abortConst.signal\n    }).then(res => {\n      // Check if the response is not valid\n      if (!res.ok) {\n        throw Error(\"could not fetch valid data\");\n      }\n\n      return res.json();\n    }).then(data => {\n      setData(data[\"data\"]);\n      setError(false);\n      setIsPending(false);\n    }).catch(error => {\n      // check the type of error and do not procede further if the error was generated by the AbortController\n      if (error.name === \"AbortError\") {\n        console.log(\"Fetch aborted!\");\n      } else {\n        setError(error.message);\n        setIsPending(false);\n      }\n    }); // This return code is run when the Hook is not used anymore. Here we avoid that further modifications to the DOM are applied by that hook when the targeted elements do not exist anymore\n\n    return () => {\n      abortConst.abort();\n      console.log(\"cleanup\");\n    };\n  }, [url]); // empty dependency array -> onl< runs the function after the initial rendering, additional variables which should be watched can be added to the array\n\n  return {\n    data,\n    isPending,\n    error\n  };\n};\n\n_s(useFetch, \"mR+k2PJJN2WqEvFICcpgwHhKpi0=\");\n\nexport default useFetch;","map":{"version":3,"names":["useEffect","useState","useFetch","url","data","setData","isPending","setIsPending","error","setError","abortConst","AbortController","fetch","signal","then","res","ok","Error","json","catch","name","console","log","message","abort"],"sources":["/home/martin/IT/git/react-playground/frontend/src/useFetch.js"],"sourcesContent":["import { useEffect, useState } from \"react\"\n\n\n// custom Hooks in React need to start with \"use\"\nconst useFetch = (url) => {\n    const [data, setData] = useState(null)\n\n    const [isPending, setIsPending] = useState(true)\n    const [error, setError] = useState(false)\n\n\n    // useEffect runs a function after every render of the component\n    // If the state of the page is changed in useEffect, this triggers a rerender and then an infinite loop\n    useEffect(() => {\n        const abortConst = new AbortController();\n        // this { signal : abortConst.signal } prevents the fetch from running normally after abortConst.abort() is fired. Anyway this, throws an error so we still end up in the catch block and the code there is executed\n        fetch(url, { signal : abortConst.signal })\n            .then((res) => {\n                // Check if the response is not valid\n                if (!res.ok) {\n                    throw Error(\"could not fetch valid data\")\n                }\n                return res.json()\n            })\n            .then((data) => {\n                setData(data[\"data\"])\n                setError(false)\n                setIsPending(false)\n            })\n            .catch(error => {\n                // check the type of error and do not procede further if the error was generated by the AbortController\n                if (error.name === \"AbortError\"){\n                    console.log(\"Fetch aborted!\")\n                } else {\n                    setError(error.message)\n                    setIsPending(false)\n                }\n            })\n            // This return code is run when the Hook is not used anymore. Here we avoid that further modifications to the DOM are applied by that hook when the targeted elements do not exist anymore\n            return() => {\n                abortConst.abort()\n                console.log(\"cleanup\")\n            }\n    }, [url]) // empty dependency array -> onl< runs the function after the initial rendering, additional variables which should be watched can be added to the array\n\n    return {data, isPending, error}\n}\n\nexport default useFetch;"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC,C,CAGA;;AACA,MAAMC,QAAQ,GAAIC,GAAD,IAAS;EAAA;;EACtB,MAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBJ,QAAQ,CAAC,IAAD,CAAhC;EAEA,MAAM,CAACK,SAAD,EAAYC,YAAZ,IAA4BN,QAAQ,CAAC,IAAD,CAA1C;EACA,MAAM,CAACO,KAAD,EAAQC,QAAR,IAAoBR,QAAQ,CAAC,KAAD,CAAlC,CAJsB,CAOtB;EACA;;EACAD,SAAS,CAAC,MAAM;IACZ,MAAMU,UAAU,GAAG,IAAIC,eAAJ,EAAnB,CADY,CAEZ;;IACAC,KAAK,CAACT,GAAD,EAAM;MAAEU,MAAM,EAAGH,UAAU,CAACG;IAAtB,CAAN,CAAL,CACKC,IADL,CACWC,GAAD,IAAS;MACX;MACA,IAAI,CAACA,GAAG,CAACC,EAAT,EAAa;QACT,MAAMC,KAAK,CAAC,4BAAD,CAAX;MACH;;MACD,OAAOF,GAAG,CAACG,IAAJ,EAAP;IACH,CAPL,EAQKJ,IARL,CAQWV,IAAD,IAAU;MACZC,OAAO,CAACD,IAAI,CAAC,MAAD,CAAL,CAAP;MACAK,QAAQ,CAAC,KAAD,CAAR;MACAF,YAAY,CAAC,KAAD,CAAZ;IACH,CAZL,EAaKY,KAbL,CAaWX,KAAK,IAAI;MACZ;MACA,IAAIA,KAAK,CAACY,IAAN,KAAe,YAAnB,EAAgC;QAC5BC,OAAO,CAACC,GAAR,CAAY,gBAAZ;MACH,CAFD,MAEO;QACHb,QAAQ,CAACD,KAAK,CAACe,OAAP,CAAR;QACAhB,YAAY,CAAC,KAAD,CAAZ;MACH;IACJ,CArBL,EAHY,CAyBR;;IACA,OAAM,MAAM;MACRG,UAAU,CAACc,KAAX;MACAH,OAAO,CAACC,GAAR,CAAY,SAAZ;IACH,CAHD;EAIP,CA9BQ,EA8BN,CAACnB,GAAD,CA9BM,CAAT,CATsB,CAuCZ;;EAEV,OAAO;IAACC,IAAD;IAAOE,SAAP;IAAkBE;EAAlB,CAAP;AACH,CA1CD;;GAAMN,Q;;AA4CN,eAAeA,QAAf"},"metadata":{},"sourceType":"module"}